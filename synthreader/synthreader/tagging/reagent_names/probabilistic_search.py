from typing import Optional, List, Tuple
import os
from ...words import Word
from .utils import (
    remove_sub_phrases,
    resolve_overlapping_phrases,
    get_candidate_phrases,
    apply_reagent_names
)
from .constants import MAX_REAGENT_NAME_LENGTH, P_GENERAL_PHRASE_IS_REAGENT

HERE = os.path.abspath(os.path.dirname(__file__))

def load_probabilities(file_name: str) -> List[Tuple[str, float, float]]:
    """Given file name load fragments and associated probabilities. File must be
    TSV of format:
        frag\tp_frag_in_reagent_name\tp_frag_in_non_reagent_phrase\n

    Args:
        file_name (str): File name to load fragments/probabilities from.

    Returns:
        List[Tuple[str, float, float]]: List of tuples of format:
            [(frag, p_frag_in_reagent_name, p_frag_in_non_reagent_phrase)...]
    """
    with open(file_name, encoding='utf-8') as fileobj:
        rows = [line.strip().split('\t')
                for line in fileobj.readlines() if line]
        return [(row[0], float(row[1]), float(row[2])) for row in rows]


PROBABILITY_FILE_NAMES = [
    'p_fragments_len3_reagents.tsv',
    'p_fragments_len3_non_reagents.tsv',
    'p_fragments_len2_reagents.tsv',
    'p_fragments_len4_reagents.tsv',
]

# Make feature list
FEATURES = []
for file_name in PROBABILITY_FILE_NAMES:
    FEATURES.extend(
        load_probabilities(os.path.join(HERE, 'probabilities', file_name)))

# Remove duplicates
encountered = []
for i in reversed(range(len(FEATURES))):
    frag = FEATURES[i][0]
    if frag in encountered:
        FEATURES.pop(i)
    else:
        encountered.append(frag)

# Sort by most certain in either way.
FEATURES = sorted(FEATURES, key=lambda x: 1 / (max(x[1], x[2])))

def p_phrase_is_reagent(
    phrase: str, p_general_phrase_is_reagent: Optional[float] = 0.45
) -> float:
    """Use bayes theorem to determine probability that given phrase is a
    reagent, using probabilities associated with small word fragments appearing
    in reagent names and non reagent names. Probabilities are calculated for all
    features, and the mean is taken.

    Args:
        phrase (str): Phrase to predict whether or not it is a reagent name.
        p_general_phrase_is_reagent (float): Probability (value between 0 and 1)
            that a given phrase is a reagent regardless of what features it
            contains.

            NOTE: This value is probably around 0.1 based on the
            phrases generated by get_candidate_phrases. However, because false
            negatives are so much harder to deal with than false positives (
            false positives you can just add a word to
            REAGENT_NAME_IGNORE_WORD_LIST) a value of at least 0.45 should be
            used. If you have trouble with false negatives increase this value
            and deal with the resulting false positives by adding words to
            REAGENT_NAME_IGNORE_WORD_LIST.

    Returns:
        float: Value between 0 and 1 representing probability the phrase is a
            reagent name. 0 is definitely not a reagent name, 1 is definitely a
            reagent name.
    """
    p_general_phrase_is_non_reagent = 1 - p_general_phrase_is_reagent
    ps = [p_general_phrase_is_reagent]
    for feature, p_feature_in_reagent, p_feature_in_non_reagent in FEATURES:
        if feature in phrase:
            numerator = p_feature_in_reagent * p_general_phrase_is_reagent
            denominator = (
                (p_feature_in_reagent * p_general_phrase_is_reagent)
                + (p_feature_in_non_reagent * p_general_phrase_is_non_reagent)
            )
            ps.append(numerator / denominator)

    return sum(ps) / len(ps)

def naive_bayes_reagent_name_tag(
        sentences: List[List[Word]]) -> List[List[Word]]:
    """Use Naive Bayes classification to find reagent names in sentences and
    combine the Word objects into ReagentNameWord objects.

    Args:
        sentences (List[List[Word]]): Sentences to find reagent names in.

    Returns:
        List[List[Word]]: Sentences with reagent names converted into
            ReagentNameWord objects.
    """
    reagent_name_positions = []
    # Get candidate phrases
    phrases = get_candidate_phrases(
        sentences, max_length=MAX_REAGENT_NAME_LENGTH)
    # Search for all reagent names in all phrases.
    for phrase in phrases:
        if p_phrase_is_reagent(
            phrase[0],
            p_general_phrase_is_reagent=P_GENERAL_PHRASE_IS_REAGENT
        ) >= 0.5:
            reagent_name_positions.append(phrase[1])
    # Remove sub phrases from reagent name positions, resolve overlaps and turn
    # reagent names to into ReagentName words.
    reagent_name_positions = remove_sub_phrases(reagent_name_positions)
    reagent_name_positions = resolve_overlapping_phrases(reagent_name_positions)
    sentences = apply_reagent_names(sentences, reagent_name_positions)
    return sentences
